<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JVM on Lay-z's Blog</title><link>/java_core/jvm/virtual_machine/</link><description>Recent content in JVM on Lay-z's Blog</description><generator>Hugo</generator><language>en</language><copyright>Copyright (c) 2020-2024 Thulite</copyright><lastBuildDate>Thu, 07 Sep 2023 16:04:48 +0200</lastBuildDate><atom:link href="/java_core/jvm/virtual_machine/index.xml" rel="self" type="application/rss+xml"/><item><title>虚拟机</title><link>/java_core/jvm/virtual_machine/virtual-machine/</link><pubDate>Thu, 07 Sep 2023 16:04:48 +0200</pubDate><guid>/java_core/jvm/virtual_machine/virtual-machine/</guid><description>&lt;h1 id="section-1"&gt;什么是虚拟机？&lt;/h1&gt;
&lt;h1 id="chapter-1"&gt;一、虚拟机&lt;/h1&gt;
&lt;h2 id="section-1-1"&gt;1. 什么是虚拟机？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;虚拟机(Virtual Machine)指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。&lt;/li&gt;
&lt;li&gt;所谓虚拟机，就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="section-1-2"&gt;2. 虚拟机可以分为两类：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;系统虚拟机：它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台，比如Visual Box，VMware。&lt;/li&gt;
&lt;li&gt;程序虚拟机：专门为执行单个计算机程序而设计，比如Java虚拟机，在Java虚拟机中执行的指令称为Java字节码指令。
无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id="chapter-2"&gt;二、Java虚拟机&lt;/h1&gt;
&lt;h2 id="section-2-1"&gt;1. 什么是Java虚拟机？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Java虚拟机是一台执行字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。&lt;/li&gt;
&lt;li&gt;JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回收机制，以及可靠的即时编译器。&lt;/li&gt;
&lt;li&gt;Java技术的核心就是Java虚拟机，因为所有的Java程序都运行在Java虚拟机内部。
&lt;strong&gt;可以这样理解:&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;JVM类似于一台小电脑运行在windows或者linux这些操作系统环境下。它与操作系统直接交互，不与硬件直接交互，操作系统可以帮我们完成和硬件交互的工作。&lt;/li&gt;
&lt;li&gt;JVM不是只支持Java字节码，只要编程语言能够遵循字节码文件的规范，都可以在JVM内运行
     

&lt;img
 src="/1592291665856-8bc51ef9-6ee7-4408-9343-3ef1aa7372dd_319100819319602114_hu_22beb13e41938c8f.webp"
 width="1705"
 height="315"
 decoding="async"
 fetchpriority="auto"
 loading="lazy"
 alt=""
 id="h-rh-i-0"
&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="section-2-2"&gt;2. Java虚拟机是干什么的？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。&lt;/li&gt;
&lt;li&gt;每一条Java指令，Java虚拟机规范中都有详细的定义，如怎么取操作数，怎么处理操作数，操作结果放在哪里。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="section-2-3"&gt;3. Java虚拟机的主要特点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;一次编译，到处运行&lt;/li&gt;
&lt;li&gt;自动内存管理&lt;/li&gt;
&lt;li&gt;自动垃圾回收机制
&lt;strong&gt;&amp;ldquo;一次编译，到处运行&amp;quot;怎么理解？&lt;/strong&gt;
对于不同的操作系统，Oracle提供了不同版本的JVM，所以只需要将程序编译成一个.class文件，就可以运行在不同操作系统的JVM上


&lt;img
 src="/1592291938421-f47f0246-9e23-46e4-98ef-d642dc9d0ecd_9415740850356539932_hu_4d77ddbcd375a312.webp"
 width="936"
 height="543"
 decoding="async"
 fetchpriority="auto"
 loading="lazy"
 alt=""
 id="h-rh-i-1"
&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="section-2-4"&gt;4. 指令集架构模型&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;基于栈的指令集架构&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;设计和实现更简单，适用于资源受限的系统；&lt;/li&gt;
&lt;li&gt;避开了寄存器的分配难题：使用&lt;strong&gt;零地址指令&lt;/strong&gt;方式分配；&lt;/li&gt;
&lt;li&gt;JVM指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现；&lt;/li&gt;
&lt;li&gt;不需要硬件支持，可移植性更好，更好实现跨平台。
由于跨平台性的设计，Java的指令都是根据栈来设计的。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="2"&gt;
&lt;li&gt;基于寄存器的指令集架构&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;典型的应用是X86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机；&lt;/li&gt;
&lt;li&gt;基于寄存器的指令集架构则完全依赖硬件，可移植性差；&lt;/li&gt;
&lt;li&gt;性能优秀，执行更高效；&lt;/li&gt;
&lt;li&gt;花费更少的指令去完成一项操作；&lt;/li&gt;
&lt;li&gt;大部分情况下，基于寄存器架构的指令集往往都以&lt;strong&gt;一地址指令&lt;/strong&gt;、&lt;strong&gt;二地址指令&lt;/strong&gt;和&lt;strong&gt;三地址指令&lt;/strong&gt;为主&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="3"&gt;
&lt;li&gt;二者区别：举例说明
 

&lt;img
 src="/1592292964453-ba574a07-3d16-4688-b2a5-363318ee2861_4299550262335268628_hu_14cf74460b18abfa.webp"
 width="1333"
 height="781"
 decoding="async"
 fetchpriority="auto"
 loading="lazy"
 alt=""
 id="h-rh-i-2"
&gt;
&lt;strong&gt;寄存器执行性能更好，为什么不更改成根据寄存器来设计？&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;不同平台CPU架构不同，为了实现跨平台性，所以不能设计为基于寄存器的；&lt;/li&gt;
&lt;li&gt;基于栈设计实现要简单一些；&lt;/li&gt;
&lt;li&gt;基于栈在非资源受限平台(嵌入式)也是可以用的，没有必要更改。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-2-5"&gt;5. JVM的生命周期&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;启动&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Java虚拟机的启动是通过引导类加载器(bootstrap class loader)创建一个初始类(initial class)来完成的，这个类是由虚拟机的具体实现(虚拟机有不同公司开发的不同的版本)指定的。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="2"&gt;
&lt;li&gt;执行&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序；&lt;/li&gt;
&lt;li&gt;程序开始执行时他才运行，程序结束时他就停止；&lt;/li&gt;
&lt;li&gt;执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="3"&gt;
&lt;li&gt;退出&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;程序正常执行结束；&lt;/li&gt;
&lt;li&gt;程序在执行过程中遇到了异常(未被捕获)或错误而异常终止；&lt;/li&gt;
&lt;li&gt;由于操作系统出现错误而导致Java虚拟机进程终止；&lt;/li&gt;
&lt;li&gt;某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且Java安全管理也允许这次exit或halt操作。&lt;/li&gt;
&lt;li&gt;JNI加载或卸载Java虚拟机，Java虚拟机退出&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-2-6"&gt;6. JVM整体结构&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;整体结构图


&lt;img
 src="/1592293238440-5c0e5309-8c0f-4380-9b5c-9f17197371ee_8685009371071052695_hu_220652c16a3ea774.webp"
 width="1057"
 height="954"
 decoding="async"
 fetchpriority="auto"
 loading="lazy"
 alt=""
 id="h-rh-i-3"
&gt;&lt;/li&gt;
&lt;li&gt;详细结构图


&lt;img
 src="/1592293272780-92417562-dfae-46ef-8f03-b09c94471282_17732531737385754454_hu_fdde68c71d327fc0.webp"
 width="1222"
 height="1245"
 decoding="async"
 fetchpriority="auto"
 loading="lazy"
 alt=""
 id="h-rh-i-4"
&gt;&lt;/li&gt;
&lt;/ol&gt;</description></item></channel></rss>