[{"content":"","date":"2023-09-07","id":0,"permalink":"/frameworks/spring/spring_basic/","summary":"","tags":[],"title":"Spring基础"},{"content":"一、Spring概述\n什么是框架？框架就是多个可重用模块的集合，形成一个某个领域的整体解决\nSpring框架是一个开源的容器框架。为什么叫容器？因为Spring可以管理所有的组件(类)。\nSpring的jar包三个为一组，javadoc中包含相关文档，sources是Spring源码\nSpring的优良特性\n非侵入式：基于Spring开发的应用中的对象可以不依赖于Spring的API 依赖注入：DI，IOC最经典的实现 面向切面编程：AOP 容器：Spring是一个容器，因为它包含并且管理应用对象的生命周期 组件化：Spring实现了使用简单的组件配置组合成一个复杂的应用，在Spring中可以使用XML和Java注解组合这些对象 一站式：在IOC和AOP的基础上可以整合各种企业应用的开源框架和第三方类库。从前到后，从页面到数据库都有支持 二、Spring的模块划分\nSpring框架采用分层架构，根据不同的功能被划分成了多个模块，这些模块可以满足一切企业级应用开发的需求，在开发过程中可以根据需求有选择性地使用所需要的模块。\nTest：Spring的单元测试\nspring-test-5.2.6.RELEASE.jar\nCore Container： 核心容器IOC，这些功能由以下jar包组成，如果要使用这部分功能，需要把这些jar包全部导入\nspring-beans-5.2.6.RELEASE.jar spring-core-5.2.6.RELEASE.jar spring-context-5.2.6.RELEASE.jar spring-expression-5.2.6.RELEASE.jar\nAOP+Aspects：面向切面编程\nspring-aop-5.2.6.RELEASE.jar spring-aspects-5.2.6.RELEASE.jar\nData Access/integration：数据访问/集成\n// Data Access spring-jdbc-5.2.6.RELEASE.jar spring-orm-5.2.6.RELEASE.jar // 对象关系映射 spring-tx-5.2.6.RELEASE.jar // 事务\n// integration spring-oxm-5.2.6.RELEASE.jar // 对象XML映射 spring-jms-5.2.6.RELEASE.jar\nWeb：Spring开发Web应用的模块\nspring-websocket-5.2.6.RELEASE.jar // 新技术 spring-web-5.2.6.RELEASE.jar // 原生web相关(servlet) spring-webmvc-5.2.6.RELEASE.jar // 开发web项目的 spring-webflux-5.2.6.RELEASE.jar // 开发web应用的组件集成\n三、Spring的学习\n学习Spring主要学习两个内容：IOC(容器)和AOP(面向切面编程)，学习IOC之后，可以将Spring与MyBatis、Struts2等进行整合，学习AOP主要是因为后续需要学习声明式事务，而学习事务就需要与数据库打交道，所以不可避免需要学习JdbcTemplate\n","date":"2023-09-07","id":1,"permalink":"/frameworks/spring/spring_basic/spring-basic/","summary":"\u003cp\u003e一、Spring概述\u003c/p\u003e\n\u003cp\u003e什么是框架？框架就是多个可重用模块的集合，形成一个某个领域的整体解决\u003c/p\u003e\n\u003cp\u003eSpring框架是一个开源的容器框架。为什么叫容器？因为Spring可以管理所有的组件(类)。\u003c/p\u003e\n\u003cp\u003eSpring的jar包三个为一组，javadoc中包含相关文档，sources是Spring源码\u003c/p\u003e\n\u003cp\u003eSpring的优良特性\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e非侵入式：基于Spring开发的应用中的对象可以不依赖于Spring的API\u003c/li\u003e\n\u003cli\u003e依赖注入：DI，IOC最经典的实现\u003c/li\u003e\n\u003cli\u003e面向切面编程：AOP\u003c/li\u003e\n\u003cli\u003e容器：Spring是一个容器，因为它包含并且管理应用对象的生命周期\u003c/li\u003e\n\u003cli\u003e组件化：Spring实现了使用简单的组件配置组合成一个复杂的应用，在Spring中可以使用XML和Java注解组合这些对象\u003c/li\u003e\n\u003cli\u003e一站式：在IOC和AOP的基础上可以整合各种企业应用的开源框架和第三方类库。从前到后，从页面到数据库都有支持\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e二、Spring的模块划分\u003c/p\u003e\n\u003cp\u003eSpring框架采用分层架构，根据不同的功能被划分成了多个模块，这些模块可以满足一切企业级应用开发的需求，在开发过程中可以根据需求有选择性地使用所需要的模块。\u003c/p\u003e\n\u003cp\u003eTest：Spring的单元测试\u003c/p\u003e\n\u003cp\u003espring-test-5.2.6.RELEASE.jar\u003c/p\u003e\n\u003cp\u003eCore Container：\n核心容器IOC，这些功能由以下jar包组成，如果要使用这部分功能，需要把这些jar包全部导入\u003c/p\u003e\n\u003cp\u003espring-beans-5.2.6.RELEASE.jar\nspring-core-5.2.6.RELEASE.jar\nspring-context-5.2.6.RELEASE.jar\nspring-expression-5.2.6.RELEASE.jar\u003c/p\u003e","tags":[],"title":"Spring框架概述"},{"content":"一、什么是AOP？ AOP(Aspect Oriented Programming)指的是面向切面编程，它的出现并不是用来替代OOP(Object Oriented Programming)的，而是基于OOP(Object Oriented Programming)基础之上新的编程思想。\n面向切面编程，通俗一点说，就是指将某段代码动态的切入到指定方法的指定位置进行运行的编程方式。\n举个例子，假设我们有加减乘除四个方法，并且要在每个方法运行的时候添加日志记录，有以下几种做法：\n1.直接编写在方法内部；\npublic class NumberUtil { public static int add(int i, int j) { System.out.println(\u0026#34;运行add..，参数是\u0026#34; + i + \u0026#34;,\u0026#34; + j); int result = i + j; System.out.println(\u0026#34;运行add..，结果是\u0026#34; + result); return result; } public static int sub(int i, int j) { System.out.println(\u0026#34;运行sub..，参数是\u0026#34; + i + \u0026#34;,\u0026#34; + j); int result = i - j; System.out.println(\u0026#34;运行sub..，结果是\u0026#34; + result); return result; } public static int mul(int i, int j) { System.out.println(\u0026#34;运行mul..，参数是\u0026#34; + i + \u0026#34;,\u0026#34; + j); int result = i * j; System.out.println(\u0026#34;运行mul..，结果是\u0026#34; + result); return result; } public static int div(int i, int j) { System.out.println(\u0026#34;运行div..，参数是\u0026#34; + i + \u0026#34;,\u0026#34; + j); int result = i / j; System.out.println(\u0026#34;运行div..，结果是\u0026#34; + result); return result; } }\r加减乘除是业务核心逻辑，添加日志记录只是系统的辅助功能，直接将日志记录编写在方法内部，导致业务核心逻辑和系统辅助功能代码耦合，代码可读性差，并且修改维护麻烦，所以不推荐这么做。\n2.写一个工具类，在方法内部调用工具类\npublic class NumberUtil { public static int add(int i, int j) { LogUtil.logStart(i,j); int result = i + j; LogUtil.logEnd(i,j); return result; } public static int sub(int i, int j) { LogUtil.logStart(i,j); int result = i - j; LogUtil.logEnd(i,j); return result; } public static int mul(int i, int j) { LogUtil.logStart(i,j); int result = i * j; LogUtil.logEnd(i,j); return result; } public static int div(int i, int j) { LogUtil.logStart(i,j); int result = i / j; LogUtil.logEnd(i,j); return result; } } public class LogUtil { public static void logStart(Object...objects) { System.out.println(\u0026#34;运行\u0026#34; + Arrays.asList(objects)); } public static void logEnd(Object...objects) { System.out.println(\u0026#34;结束运行\u0026#34; + Arrays.asList(objects)); } }\r写工具类的好处是如果需要修改日志的输出，只需要改日志工具类即可，但是这种方式日志记录和业务逻辑代码还是耦合，而且可能很多功能都需要调用LogUtil，需要考虑不同业务的兼容性问题。\n3.采用动态代理的方式\n采用动态代理的意思是，假设我们有一个NumberUtil类的代理对象，我们通过代理对象去执行NumberUtil的加减乘除方法，就可以在方法前后做其他操作，而且不会影响NumberUtil类中本身的业务逻辑。\npublic interface BaseNumberUtil { public int add(int i, int j); public int sub(int i, int j); public int mul(int i, int j); public int div(int i, int j); } public class NumberUtil implements BaseNumberUtil{ @Override public int add(int i, int j) { return i + j; } @Override public int sub(int i, int j) { return i - j; } @Override public int mul(int i, int j) { return i * j; } @Override public int div(int i, int j) { return i / j; } } public class LogUtil { public static void logStart(Method method, Object... args) { System.out.println(method.getName() + \u0026#34;方法开始执行，传入的参数是\u0026#34; + Arrays.asList(args)); } public static void logEnd(Method method, Object... result) { System.out.println(method.getName() + \u0026#34;方法执行结束，返回的结果是\u0026#34; + Arrays.asList(result)); } public static void logException(Method method, Exception e) { System.out.println(method.getName() + \u0026#34;方法执行异常，异常信息是\u0026#34; + e.getCause()); } public static void logFinally(Method method) { System.out.println(method.getName() + \u0026#34;方法执行结束\u0026#34;); } } /** * 帮NumberUtil.java生成代理对象 */ public class NumberUtilProxy { /** * 为传入的参数创建一个代理对象 * * @param numberUtil 被代理的对象 * @return */ public static BaseNumberUtil getProxy(final BaseNumberUtil numberUtil){ // 被代理对象的类加载器 ClassLoader loader = numberUtil.getClass().getClassLoader(); // 对象所实现的所有接口 Class\u0026lt;?\u0026gt;[] interfaces = numberUtil.getClass().getInterfaces(); // 方法执行器，帮我们目标对象执行方法 InvocationHandler h = new InvocationHandler() { /** * @param proxy 代理对象，给jdk使用，任和时候都不要懂这个对象 * @param method 当前将要执行的目标对象的方法 * @param args 这个方法调用时外界传入的参数值 * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object result = null; try { LogUtil.logStart(method,args); // 利用反射执行目标方法 result = method.invoke(numberUtil, args); LogUtil.logEnd(method,result); } catch (Exception e){ LogUtil.logException(method,e); } finally { LogUtil.logFinally(method); } // result是目标方法执行后的返回值，将目标方法执行结果返回,只有将执行结果返回出去，外界才能拿到真正执行后的返回值 return result; } }; // Proxy为目标对象创建代理对象，这个方法是jdk的，直接用，作用就是为目标对象创建代理对象 return (BaseNumberUtil) Proxy.newProxyInstance(loader,interfaces,h); } } public class TestNumberUtilProxy { @Test public void test(){ BaseNumberUtil numberUtil = new NumberUtil(); // 拿到了NumberUtil的代理对象，这个代理对象最终也会去调用NumberUtil的加减乘除方法 BaseNumberUtil proxy = NumberUtilProxy.getProxy(numberUtil); /** * add方法开始执行，传入的参数是[1, 2] * add方法执行结束，返回的结果是[3] * add方法执行结束 */ proxy.add(1,2); /** * sub方法开始执行，传入的参数是[1, 2] * sub方法执行结束，返回的结果是[-1] * sub方法执行结束 */ proxy.sub(1,2); /** * mul方法开始执行，传入的参数是[2, 3] * mul方法执行结束，返回的结果是[6] * mul方法执行结束 */ proxy.mul(2,3); /** * div方法开始执行，传入的参数是[2, 0] * div方法执行异常，异常信息是java.lang.ArithmeticException: / by zero * div方法执行结束 */ proxy.div(2,0); } }\r用动态代理，日志记录可以做的非常强大，而且与业务逻辑解耦。但是动态代理存在两个问题。\n第一个问题，动态代理写起来很复杂，不同的业务需要创建不同的代理类；\n第二个问题，jdk默认的动态代理，如果目标对象没有实现任何接口，是无法为他创建代理对象的。我们在创建代理的时候，传入了一个参数interfaces，这个参数是对象所实现的所有接口，代理对象也实现了被代理对象实现的接口，换句话说，代理对象和被代理对象唯一产生的关联是实现了同一个接口。所以，如果目标对象没有实现任何接口，就无法为他创建代理对象。\nSpring为了解决动态代理上述的两个问题，产生了AOP，AOP底层就是动态代理。我们可以利用Spring一句代码都不写的去创建动态代理。AOP实现简单，而且不要求目标对象必须实现某个接口。\n二、AOP中的专业术语 以给方法添加日志为例，如果不给方法添加日志，正常情况下，方法会直接运行业务逻辑直至结束。但是我们想要在方法开始前，方法结束后，方法出现异常，方法完全结束的地方添加日志。\n**横切关注点：**方法不同的位置就是我们的横切关注点。\n**通知方法：**业务逻辑方法不同位置调用的日志记录方法就是通知方法。\n**切面类：**写了通知方法的类，就叫做切面类。\n**连接点：**每一个方法的每一个位置都是一个连接点，切面类的方法和业务逻辑方法可以在连接点建立连接。\n**切入点：**可能我们只需要在方法异常的时候记录日志，并不是每一个点都记录日志。我们真正需要执行日志记录的地方就叫做切入点。\n**切入点表达式：**在众多连接点中选出我们感兴趣的地方。就好比sql语句，从众多数据中选出我们需要的一些数据。\n三、AOP的操作 1. AOP的使用步骤 上面介绍了手动编写动态代理的方式实现切面编程，那么如何使用Spring将切面类LogUtil中的通知方法动态的在目标方法运行的各个位置切入呢？我们的目标是在没有自己编写动态代理的情况下，让Spring替我们实现将日志记录插入到方法运行的不同位置。\n第一步：导包\n// Spring基础包 spring-expression-5.2.6.RELEASE.jar spring-core-5.2.6.RELEASE.jar spring-context-5.2.6.RELEASE.jar spring-beans-5.2.6.RELEASE.jar spring-aop-5.2.6.RELEASE.jar commons-logging-1.2.jar // Spring支持面向切面编程的包——基础版 spring-aspects-5.2.3.RELEASE.jar // Spring支持面向切面编程的包——增强版(即使目标对象没有实现任何接口，也可以实现动态代理) com.springsource.org.aspectj.weaver-1.7.2.RELEASE.jar aopalliance-1.0-sources.jar cglib-nodep-javadoc-2.2.jar\r第二步：写配置\n1.将目标类和切面类(封装了通知方法(在目标方法执行前后执行的方法)的类)加入到IOC容器中\n\u0026lt;!--开启组件扫描--\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.ysy\u0026#34;\u0026gt;\u0026lt;/context:component-scan\u0026gt;\r@Component public class LogUtil {} @Component public class NumberUtil implements BaseNumberUtil{}\r2.告诉Spring，哪个是切面类\n@Component @Aspect // 告诉Spring，这个类是切面类 public class LogUtil {}\r3.告诉Spring，通知方法要在何时何地运行\n@Component @Aspect // 告诉Spring，这个类是切面类 public class LogUtil { /** * 告诉Spring，每个方法都什么时候运行 * @Before 前置通知 * @After() 后置通知 * @AfterReturning 返回通知 * @AfterThrowing 异常通知 * @Around() 环绕通知 */ // 目标方法开始执行之前执行 // execution是固定写法，如果你的方法有参数，这里必须也写参数类型，否则找不到该方法 @Before(\u0026#34;execution(public int com.ysy.learn.common.util.NumberUtil.*(int,int))\u0026#34;) public static void logStart() { System.out.println(\u0026#34;方法开始执行，传入的参数是\u0026#34;); } // 目标方法正常执行结束，拿到返回结果的时候执行 @AfterReturning(\u0026#34;execution(public int com.ysy.learn.common.util.NumberUtil.*(int,int))\u0026#34;) public static void logEnd() { System.out.println(\u0026#34;方法执行结束，返回的结果是\u0026#34;); } // 目标方法发生异常之后执行 @AfterThrowing(\u0026#34;execution(public int com.ysy.learn.common.util.NumberUtil.*(int,int))\u0026#34;) public static void logException() { System.out.println(\u0026#34;方法执行异常，异常信息是\u0026#34;); } // 目标方法执行结束之后执行 @After(\u0026#34;execution(public int com.ysy.learn.common.util.NumberUtil.*(int,int))\u0026#34;) public static void logFinally() { System.out.println(\u0026#34;方法执行结束\u0026#34;); } }\r4.开启基于注解的AOP功能\n\u0026lt;!--开启基于注解的AOP功能--\u0026gt; \u0026lt;aop:aspectj-autoproxy\u0026gt;\u0026lt;/aop:aspectj-autoproxy\u0026gt;\r第三步：测试\npublic class TestNumberUtilProxy { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicatioonContext.xml\u0026#34;); @Test public void test(){ /** * 从IOC容器中拿到目标对象 * 这里为什么不用new，因为只有从容器中拿的对象才是受容器管理的，才能使用容器强大的功能 * 如果要用类型获取对象，一定要使用接口类型，不能使用本类 */ BaseNumberUtil bean = context.getBean(BaseNumberUtil.class); /** * logStart——XXX方法开始执行，传入的参数是 * logFinally——XXX方法执行结束 * logEnd——XXX方法执行结束，返回的结果是 */ bean.add(1,2); } }\r2. AOP的使用细节 2.1 IOC容器中保存的组件是代理对象 我们从IOC容器中拿到目标对象，然后打印目标对象，会发现打印的是com.ysy.learn.common.util.NumberUtil@53aad5d5，接着打印目标对象的类型，发现打印的是class com.sun.proxy.$Proxy21，也就是说，容器中保存的组件不是NumberUtil本身，而是它的代理对象$Proxy21。这也侧面反应了AOP的底层实现是动态代理。\npublic void test(){ /** * 从IOC容器中拿到目标对象 * 这里为什么不用new，因为只有从容器中拿的对象才是受容器管理的，才能使用容器强大的功能 * 如果要用类型获取对象，一定要使用接口类型，不能使用本类 */ BaseNumberUtil bean = context.getBean(BaseNumberUtil.class); // com.ysy.learn.common.util.NumberUtil@53aad5d5 System.out.println(bean); // class com.sun.proxy.$Proxy21 System.out.println(bean.getClass()); bean.add(1,2); }\r为什么说如果要用类型获取对象，一定要使用接口类型获取，不能使用本类获取呢？\n因为容器中保存的组件不是NumberUtil本身，而是它的代理对象$Proxy21，很显然，NumberUtil和$Proxy21不是同一个对象，使用本类NumberUtil获取，就会报如下错误：\nNoSuchBeanDefinitionException: No qualifying bean of type \u0026#39;com.ysy.learn.common.util.NumberUtil\u0026#39; available\r而代理对象与目标对象唯一的关联就是他俩都实现了同一个接口，所以我们在用类型获取对象的时候，一定要使用接口类型，不能使用本类。\n我们的接口BaseNumberUtil上面并没有添加Spring创建对象的注解，说明BaseNumberUtil没有加入Spring容器中，那我们为什么还能从Spring容器中获取到对象呢？\nSpring会在容器中找已存在的组件，然后看哪一个组件是BaseNumberUtil类型。NumberUtil和LogUtil都是容器中已经存在的组件，但是NumberUtil实现了BaseNumberUtil接口，所以很显然NumberUtil是BaseNumberUtil类型，所以可以获取到对象。\n为什么不在BaseNumberUtil接口上面添加注解，让BaseNumberUtil也加入Spring容器中呢？\n实际上，BaseNumberUtil接口也可以添加创建对象的注解，而且即使加了注解，Spring也不会去为接口创建对象(无法为接口创建对象)。在接口上添加创建对象的注解，相当于告诉Spring，IOC容器中可能有这种类型的组件。\n当然，只有某个类需要被动态切入其他方法，才会给这个类创建代理对象，如果我们没有切面类，就意味着这个类不需要被切入，就不会创建代理对象，所以此时获取到的对象类型就是他本身的类型。\n@Component //Aspect // 注释切面类的注解，就不存在切面类 public class LogUtil {} public void test(){ BaseNumberUtil bean = context.getBean(BaseNumberUtil.class); // com.ysy.learn.common.util.NumberUtil@2145b572 System.out.println(bean); // class com.ysy.learn.common.util.NumberUtil System.out.println(bean.getClass()); bean.add(1,2); }\r上述方式中，NumberUtil实现了BaseNumberUtil接口，我们在上面说过，AOP的增强包，即使目标对象没有实现任何接口，也可以实现动态代理。现在我们还是创建NumberUtil，不实现BaseNumberUtil接口，然后直接用NumberUtil本类在容器中获取对象，查看这个对象的类型，发现当前对象的类型是com.ysy.learn.common.util.NumberUtil$$EnhancerBySpringCGLIB$$36a3457f，这意味着我们拿到的类型是NumberUtil，然后CGLIB帮我们在这个类中创建了一个内部类EnhancerBySpringCGLIB，这个内部类实现了NumberUtil的所有方法，这个内部类就是NumberUtil的代理对象。\n/** * NumberUtil没有实现BaseNumberUtil接口，我们还是使用LogUtil作为切面类 */ @Component public class NumberUtil /*implements BaseNumberUtil*/{ //@Override public int add(int i, int j) { return i + j; } //@Override public int sub(int i, int j) { return i - j; } //@Override public int mul(int i, int j) { return i * j; } //@Override public int div(int i, int j) { return i / j; } } /** * 测试是否打印日志信息，并且查看拿到的目标对象的Class */ public void test1(){ NumberUtil bean = context.getBean(NumberUtil.class); // com.ysy.learn.common.util.NumberUtil@437da279 System.out.println(bean); // class com.ysy.learn.common.util.NumberUtil$$EnhancerBySpringCGLIB$$36a3457f System.out.println(bean.getClass()); // logStart——XXX方法开始执行，传入的参数是 // logFinally——XXX方法执行结束 // logEnd——XXX方法执行结束，返回的结果是 bean.add(1,2); }\r2.2 切入点表达式写法 切入点表达式的固定格式：execution(访问权限符 返回值类型 方法全类名(参数列表))\n@AfterReturning(\u0026#34;execution(public int com.ysy.learn.common.util.NumberUtil.*(int,int))\u0026#34;) public static void logEnd() { System.out.println(\u0026#34;logEnd——XXX方法执行结束，返回的结果是\u0026#34;); }\r*****：\n匹配一个或多个字符：execution(public int com.ysy.learn.common.util.Number*.*(int,int))\n匹配任意一个参数：execution(public int com.ysy.learn.common.util.Number*.*(int,*))\n如果*放在路径中，只能匹配一层路径：execution(public int com.ysy.learn.common.*.Number*.*(int,*))\n*不能放在访问权限符的位置，如果要表示任意权限，访问权限符可以不写(public可选，private也切不了)\n..：\n匹配任意多个，任意类型参数：execution(public int com.ysy.learn.common.util.Number*.*(..))\n匹配多层路径：execution(public int com.ysy.learn.common..Number*.*(int,*))\n最精确的写法：execution(public int com.ysy.learn.common.util.NumberUtil.add(int,int))\n最模糊的写法：execution(* *.*(..))\n\u0026amp;\u0026amp;、||、！：\n\u0026amp;\u0026amp;：必须同时满足两个表达式execution(* *.*(..)) \u0026amp;\u0026amp; execution(* NumberUtil.*(..))\n||：满足其中一个即可execution(* *.*(..)) || execution(* NumberUtil.*(..))\n!：只要不是表达式中的方法，都做切入\n2.3 通知方法的执行顺序 不同的注解表示执行的位置如下所示：\n如果方法正常，执行的顺序是：@Before(前置通知)——\u0026gt;@After(后置通知)——\u0026gt; @AfterReturning(正常返回)\n方法异常，执行的顺序是：@Before(前置通知)——\u0026gt;@After(后置通知)——\u0026gt; @AfterThrowing(方法异常)\ntry{ @Before method.invoke(obj,args) @AfterReturning } catch { @AfterThrowing } finally { @After }\r2.4 获取目标方法的各种信息 @Component @Aspect // 告诉Spring，这个类是切面类 public class LogUtil { /** * 告诉Spring，每个方法都什么时候运行 * * @Before 前置通知 * @After() 后置通知 * @AfterReturning 返回通知 * @AfterThrowing 异常通知 * @Around() 环绕通知 */ // 目标方法开始执行之前执行 // execution是固定写法，如果你的方法有参数，这里必须也写参数类型，否则找不到该方法 @Before(\u0026#34;execution(public int com.ysy.learn.common.util.NumberUtil.*(int,int))\u0026#34;) public static void logStart(JoinPoint joinPoint) { // 获取目标方法的参数 Object[] args = joinPoint.getArgs(); // 获取目标方法的签名 Signature signature = joinPoint.getSignature(); String method = signature.getName(); System.out.println(\u0026#34;logStart——\u0026#34; + method + \u0026#34;方法开始执行，传入的参数是\u0026#34; + Arrays.asList(args)); } // 目标方法正常执行结束，拿到返回结果的时候执行，用returning告诉Spring，result是用来接收方法返回结果的 @AfterReturning(value = \u0026#34;execution(public int com.ysy.learn.common.util.NumberUtil.*(int,int))\u0026#34;, returning = \u0026#34;result\u0026#34;) // 这里的方法返回值类型如果我们写了int，就接不到其他类型的返回值 public static void logEnd(JoinPoint joinPoint, Object result) { // 获取目标方法的签名 Signature signature = joinPoint.getSignature(); String method = signature.getName(); System.out.println(\u0026#34;logEnd——\u0026#34; + method + \u0026#34;方法执行结束，返回的结果是\u0026#34; + result); } // 目标方法发生异常之后执行，用throwing告诉Spring，e是用来接收方法返回异常的 // 注意这里的Exception指定方法接收哪一种异常，如果我们这里写的NullPointerException，就接不到其他异常 @AfterThrowing(value = \u0026#34;execution(public int com.ysy.learn.common.util.NumberUtil.*(int,int))\u0026#34;, throwing = \u0026#34;e\u0026#34;) public static void logException(JoinPoint joinPoint, Exception e) { // 获取目标方法的签名 Signature signature = joinPoint.getSignature(); String method = signature.getName(); System.out.println(\u0026#34;logException——\u0026#34; + method + \u0026#34;方法执行异常，异常信息是\u0026#34;); } // 目标方法执行结束之后执行 @After(\u0026#34;execution(public int com.ysy.learn.common.util.NumberUtil.*(int,int))\u0026#34;) public static void logFinally(JoinPoint joinPoint) { // 获取目标方法的签名 Signature signature = joinPoint.getSignature(); String method = signature.getName(); System.out.println(\u0026#34;logFinally——\u0026#34; + method + \u0026#34;方法执行结束\u0026#34;); } }\r补充内容：Spring对通知方法的约束\n为什么我们在通知方法logEnd()随便加了一个Object result参数就可以接收到方法的返回值？\n首先，Spring对通知方法的约束不严格，通知方法中我们写不写static，返回值是void还是其他类型，访问权限是public还是private都不会影响通知方法的执行，唯一会影响的是通知方法的参数列表。因为通知方法是Spring通过反射调用的，每次调用通知方法，Spring都要确定这个方法参数列表的值，所以Spring得知道方法的每一个参数代表了什么。像JoinPoint，是Spring自己的接口，所以它肯定认识，我们加了一个Object result，如果不告诉Spring这个result代表什么，Spring不认识这个result，就会报错，正是因为我们用returning = \u0026quot;result\u0026quot;告诉了Spring，result是用来接收方法返回值的，所以Spring可以正确的将方法返回值给到result。\n补充内容：抽取可重用的切入点表达式\n我们在每一个通知方法上面都写了切入点表达式，可能很多方法上面的切入点表达式是一样的，后续如果想修改表达式，不方便修改。那么如何将所有相同的切入点表达式抽取出来，实现重用呢？\n// 1. 声明一个没有实现的返回void的空方法 // 2. 在方法上用@Pointcut注解，写上需要重用的切入点表达式 @Pointcut(value = \u0026#34;execution(public int com.ysy.learn.common.util.NumberUtil.*(..))\u0026#34;) public void executionCommon(){}; // 3. 在通知方法切入点表达式的位置，直接写声明的空方法的方法名 @AfterThrowing(value = \u0026#34;executionCommon()\u0026#34;, throwing = \u0026#34;e\u0026#34;) public static void logException(JoinPoint joinPoint, Exception e) { // 获取目标方法的签名 Signature signature = joinPoint.getSignature(); String method = signature.getName(); System.out.println(\u0026#34;logException——\u0026#34; + method + \u0026#34;方法执行异常，异常信息是\u0026#34;+ e); }\r2.5 环绕通知 环绕通知是Spring中最强大的通知，将前置通知、返回通知、后置通知、异常通知四合一就是环绕通知，环绕通知就相当于我们的动态代理。\n@Component @Aspect // 告诉Spring，这个类是切面类 public class LogUtil { /** * @param pjp JoinPoint的子接口，可以拿到目标方法的各种信息 * @return * @throws Throwable */ @Around(value = \u0026#34;executionCommon()\u0026#34;) public static Object logAround(ProceedingJoinPoint pjp) throws Throwable { Object proceed = null; String name = \u0026#34;\u0026#34;; try { name = pjp.getSignature().getName(); Object[] args = pjp.getArgs(); // 这个相当于@Before System.out.println(\u0026#34;[环绕前置]\u0026#34; + name + \u0026#34;开始执行，参数是\u0026#34; + Arrays.asList(args)); // 这个方法就相当于method.invoke(obj,args),返回的值就是调用的目标方法的返回值 proceed = pjp.proceed(args); // 这个相当于@AfterReturning System.out.println(\u0026#34;[返回通知]\u0026#34; + name + \u0026#34;执行正常结束，结果是\u0026#34; + proceed); } catch (Exception e) { throw new RuntimeException(e); // 这个相当于@AfterThrowing System.out.println(\u0026#34;[异常通知]\u0026#34; + name + \u0026#34;执行异常，异常信息是\u0026#34; + e); } finally { // 这个相当于@After System.out.println(\u0026#34;[环绕后置]\u0026#34; + name + \u0026#34;最终结束\u0026#34;); } // 将目标方法的返回值返回出去，外界才能接得到 return proceed; } @Pointcut(value = \u0026#34;execution(public int com.ysy.learn.common.util.NumberUtil.*(..))\u0026#34;) public void executionCommon() { } }\r补充内容：如果环绕通知和普通通知同时开启，它们的执行顺序是什么样的？\n从例子中可以看出环绕通知的执行顺序是优先于普通通知的。而且如果方法出现异常，环绕通知可以捕捉到异常信息，普通通知会认为方法正常结束，因为环绕通知中已经把异常捕捉了，到普通通知时，没有接收到异常，所以为了让普通通知接收到异常，需要throw new RuntimeException(e)。\n环绕通知因为相当于动态代理，所以它可以修改参数，修改返回结果等，可以影响到目标方法，但是普通通知不会影响到目标方法，所以一般如果只是记录日志，建议用普通通知，如果确定需要影响目标方法的逻辑等，就用环绕通知。\n@Test public void test1(){ 果要用类型获取对象，一定要使用接口类型，不能使用本类 NumberUtil bean = context.getBean(NumberUtil.class); /* [环绕前置]add开始执行，参数是[1, 2] logStart——add方法开始执行，传入的参数是[1, 2] [环绕返回通知]add执行正常结束，结果是3 [环绕后置]add最终结束 logFinally——add方法执行结束 logEnd——add方法执行结束，返回的结果是3 */ bean.add(1,2); System.out.println(\u0026#34;----------------------------\u0026#34;); /* [环绕前置]div开始执行，参数是[1, 0] logStart——div方法开始执行，传入的参数是[1, 0] [环绕异常通知]div执行异常，异常信息是java.lang.ArithmeticException: / by zero [环绕后置]div最终结束 logFinally——div方法执行结束 logEnd——div方法执行结束，返回的结果是null */ bean.div(1,0); }\r2.6 多切面运行顺序 多切面意思就是有多个切面类同时切入目标方法。所以除了LogUtil切面类，我们再写一个切面类CheckUtil，让这两个类同时切入NumberUtil类中的方法。**注意：**如果要在类中使用另一个类的切入点表达式，只需要写抽取的切入点表达式方法的全签名com.ysy.learn.common.LogUtil.executionCommon()即可。\n@Component @Aspect // 告诉Spring，这个类是切面类 public class CheckUtil { @Before(\u0026#34;com.ysy.learn.common.LogUtil.executionCommon()\u0026#34;) public static void logStart(JoinPoint joinPoint) { // 获取目标方法的参数 Object[] args = joinPoint.getArgs(); // 获取目标方法的签名 Signature signature = joinPoint.getSignature(); String method = signature.getName(); System.out.println(\u0026#34;[CheckUtil---]logStart——\u0026#34; + method + \u0026#34;方法开始执行，传入的参数是\u0026#34; + Arrays.asList(args)); } // 目标方法正常执行结束，拿到返回结果的时候执行 @AfterReturning(value = \u0026#34;com.ysy.learn.common.LogUtil.executionCommon()\u0026#34;, returning = \u0026#34;result\u0026#34;) public static void logEnd(JoinPoint joinPoint, Object result) { // 获取目标方法的签名 Signature signature = joinPoint.getSignature(); String method = signature.getName(); System.out.println(\u0026#34;[CheckUtil---]logEnd——\u0026#34; + method + \u0026#34;方法执行结束，返回的结果是\u0026#34; + result); } // 目标方法发生异常之后执行 @AfterThrowing(value = \u0026#34;com.ysy.learn.common.LogUtil.executionCommon()\u0026#34;, throwing = \u0026#34;e\u0026#34;) public static void logException(JoinPoint joinPoint, Exception e) { // 获取目标方法的签名 Signature signature = joinPoint.getSignature(); String method = signature.getName(); System.out.println(\u0026#34;[CheckUtil---]logException——\u0026#34; + method + \u0026#34;方法执行异常，异常信息是\u0026#34; + e); } // 目标方法执行结束之后执行 @After(\u0026#34;com.ysy.learn.common.LogUtil.executionCommon()\u0026#34;) public static void logFinally(JoinPoint joinPoint) { // 获取目标方法的签名 Signature signature = joinPoint.getSignature(); String method = signature.getName(); System.out.println(\u0026#34;[CheckUtil---]logFinally——\u0026#34; + method + \u0026#34;方法执行结束\u0026#34;); } }\r两个切面类同时切入NumberUtil类中的方法，之后进行测试，发现输出的日志如下：先进来的切面类后出，后进来的切面类方法先出。\n@Test public void test1(){ NumberUtil bean = context.getBean(NumberUtil.class); /* [CheckUtil---]logStart——add方法开始执行，传入的参数是[1, 2] [LogUtil---]logStart——add方法开始执行，传入的参数是[1, 2] [LogUtil---]logFinally——add方法执行结束 [LogUtil---]logEnd——add方法执行结束，返回的结果是3 [CheckUtil---]logFinally——add方法执行结束 [CheckUtil---]logEnd——add方法执行结束，返回的结果是3 */ bean.add(1,2); }\r先进后出，后进先出是什么意思呢？\n大概就是如图所示，NumberUtil的方法运行的时候，首先被CheckUtil切入，之后被LogUtil切入，之后执行NumberUtil的方法，方法执行完之后，后切入的LogUtil先执行结束，之后先切入的CheckUtil执行结束。\n为什么是先执行CheckUtil，而不是先执行LogUtil呢？\n这个默认是根据累的首字母判断的，CheckUtil的首字母C在LogUtil首字母L之前，所以先执行CheckUtil，不过可以手动设置他们的执行顺序。在切面类上用注解@Order可以设置切面类的执行顺序。进行如下设置之后，LogUtil就会先执行。\n@Component @Aspect // 告诉Spring，这个类是切面类 @Order(1) public class LogUtil {} @Component @Aspect // 告诉Spring，这个类是切面类 @Order(2) public class CheckUtil {}\r如果切面类中既有普通通知，又有环绕通知，那么执行顺序是怎样的？\n按照之前的理解，环绕通知要执行方法，所以应该是先执行两个切面类的前置通知，接着执行环绕通知，最后执行两个切面类的后置通知或异常通知。但是实际上不是这样，他的执行顺序还是按照先进后出的规则，前置通知—\u0026gt;CheckUtil的后置通知—\u0026gt;CheckUtil的返回通知—\u0026gt;LogUtil的环绕通知—\u0026gt;LogUtil的后置通知—\u0026gt;LogUtil的返回通知。因为这个环绕通知是LogUtil的环绕通知，和CheckUtil没有关系，所以它不会穿插在CheckUtil的普通通知之间。所以说，环绕通知只会影响当前切面。\n@Test public void test1(){ NumberUtil bean = context.getBean(NumberUtil.class); /* [LogUtil---][环绕前置]add开始执行，参数是[1, 2] [LogUtil---]logStart——add方法开始执行，传入的参数是[1, 2] [CheckUtil---]logStart——add方法开始执行，传入的参数是[1, 2] ---方法内部执行--- [CheckUtil---]logFinally——add方法执行结束 [CheckUtil---]logEnd——add方法执行结束，返回的结果是3 [LogUtil---][环绕返回通知]add执行正常结束，结果是3 [LogUtil---][环绕后置]add最终结束 [LogUtil---]logFinally——add方法执行结束 [LogUtil---]logEnd——add方法执行结束，返回的结果是3 */ bean.add(1,2); }\r四、AOP的使用场景 AOP加日志保存到数据库\n做权限验证\nAOP做安全检查\nAOP做事务控制\n","date":"2023-09-07","id":2,"permalink":"/frameworks/spring/spring_basic/spring-aop/","summary":"\u003ch1 id=\"一什么是aop\"\u003e一、什么是AOP？\u003c/h1\u003e\n\u003cp\u003e\u003ccode\u003eAOP(Aspect Oriented Programming)\u003c/code\u003e指的是面向切面编程，它的出现并不是用来替代\u003ccode\u003eOOP(Object Oriented Programming)\u003c/code\u003e的，而是基于\u003ccode\u003eOOP(Object Oriented Programming)\u003c/code\u003e基础之上新的编程思想。\u003c/p\u003e\n\u003cp\u003e面向切面编程，通俗一点说，就是指将某段代码动态的切入到指定方法的指定位置进行运行的编程方式。\u003c/p\u003e\n\u003cp\u003e举个例子，假设我们有加减乘除四个方法，并且要在每个方法运行的时候添加日志记录，有以下几种做法：\u003c/p\u003e\n\u003cp\u003e1.直接编写在方法内部；\u003c/p\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003epublic class NumberUtil {\n\n    public static int add(int i, int j) {\n        System.out.println(\u0026#34;运行add..，参数是\u0026#34; + i + \u0026#34;,\u0026#34; + j);\n        int result = i + j;\n        System.out.println(\u0026#34;运行add..，结果是\u0026#34; + result);\n        return result;\n    }\n\n    public static int sub(int i, int j) {\n        System.out.println(\u0026#34;运行sub..，参数是\u0026#34; + i + \u0026#34;,\u0026#34; + j);\n        int result = i - j;\n        System.out.println(\u0026#34;运行sub..，结果是\u0026#34; + result);\n        return result;\n    }\n\n    public static int mul(int i, int j) {\n        System.out.println(\u0026#34;运行mul..，参数是\u0026#34; + i + \u0026#34;,\u0026#34; + j);\n        int result = i * j;\n        System.out.println(\u0026#34;运行mul..，结果是\u0026#34; + result);\n        return result;\n    }\n\n    public static int div(int i, int j) {\n        System.out.println(\u0026#34;运行div..，参数是\u0026#34; + i + \u0026#34;,\u0026#34; + j);\n        int result = i / j;\n        System.out.println(\u0026#34;运行div..，结果是\u0026#34; + result);\n        return result;\n    }\n}\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003cp\u003e加减乘除是业务核心逻辑，添加日志记录只是系统的辅助功能，直接将日志记录编写在方法内部，导致业务核心逻辑和系统辅助功能代码耦合，代码可读性差，并且修改维护麻烦，所以不推荐这么做。\u003c/p\u003e","tags":[],"title":"Spring AOP"},{"content":"在学习声明式事务之前，我们先回忆一下什么是事务：【什么是事务】。既然是事务，就免不了要操作数据库，Spring提供了JdbcTemplate，可以快捷的操作数据库。\n一、JdbcTemplate JdbcTemplate是Spring提供的进行数据访问的工具，想要使用JdbcTemplate，首先需要导入以下三个Jar包：\nspring-jdbc-5.2.6.RELEASE.jar spring-orm-5.2.6.RELEASE.jar // 对象关系映射 spring-tx-5.2.6.RELEASE.jar // 事务\rJar包导入之后，怎么使用JdbcTemplate来操作数据库呢？\n访问数据库，首先需要知道数据源，我们可以通过new的方式获取dataSource和JdbcTemplate，然后使用JdbcTemplate中的增删改查方法即可。\npublic void test() throws SQLException, PropertyVetoException { JdbcTemplate jdbcTemplate = new JdbcTemplate(); ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setUser(\u0026#34;\u0026#34;); dataSource.setPassword(\u0026#34;\u0026#34;); dataSource.setJdbcUrl(\u0026#34;\u0026#34;); dataSource.setDriverClass(\u0026#34;\u0026#34;); jdbcTemplate.setDataSource(dataSource); }\r另外一种方式，就是在Spring容器中注册dataSource和JdbcTemplate，我们要使用JdbcTemplate的时候，直接去Spring容器中取，之后再使用JdbcTemplate中的增删改查方法来操作数据库。\n\u0026lt;!--将数据库的连接信息抽取到jdbc.properties文件中，然后引用外部属性文件(需要使用context名称空间)--\u0026gt; \u0026lt;!--加载外部配置文件 classpath:固定写法，表示引用类路径下的一个资源--\u0026gt; \u0026lt;context:property-placeholder location=\u0026#34;classpath:jdbc.properties\u0026#34;\u0026gt;\u0026lt;/context:property-placeholder\u0026gt; \u0026lt;bean id=\u0026#34;testDB1\u0026#34; class=\u0026#34;com.mchange.v2.c3p0.ComboPooledDataSource\u0026#34;\u0026gt; \u0026lt;!--${key}：动态取出配置文件中某个key对应的值 如果在配置文件中直接配置username，获取不到数据库的连接，因为username是Spring的key中的一个关键字 所以我们一般加一个前缀：jdbc.username来加以区分 --\u0026gt; \u0026lt;property name=\u0026#34;user\u0026#34; value=\u0026#34;${jdbc.username}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${jdbc.password}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;jdbcUrl\u0026#34; value=\u0026#34;${jdbc.jdbcUrl}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;driverClass\u0026#34; value=\u0026#34;${jdbc.driverClass}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;jdbcTemplate\u0026#34; class=\u0026#34;org.springframework.jdbc.core.JdbcTemplate\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;testDB1\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;\rJdbcTemplate使用示例：\npublic Double queryBookPrice(String bookId){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;bean1.xml\u0026#34;); JdbcTemplate jdbcTemplate = context.getBean(JdbcTemplate.class, \u0026#34;jdbcTemplate\u0026#34;); String sql = \u0026#34;SELECT t.price from tb_book t WHERE t.book_id = ?\u0026#34;; return jdbcTemplate.queryForObject(sql,Double.class,bookId); } public void updateBookStock(String bookId,int number){ ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;bean1.xml\u0026#34;); JdbcTemplate jdbcTemplate = context.getBean(JdbcTemplate.class, \u0026#34;jdbcTemplate\u0026#34;); String sql = \u0026#34;UPDATE tb_book_stock T SET T.stock = T.stock - ? WHERE T.book_id = ?\u0026#34;; jdbcTemplate.update(sql,number,bookId); }\rJdbcTemplate知道怎么用就行，不做重点研究。\n二、声明式事务概述 什么是编程式事务？什么是声明式事务？\n编程式事务：顾名思义，编程式事务就是通过编码的方式实现事务控制，需要在程序中显式地调用事务管理的相关方法。\n声明式事务：不需要编写复杂的事务控制代码，只需要声明一个方法是事务方法，然后Spring就会自动进行事务控制。\n为什么声明了事务方法，Spring就可以进行事务控制了呢？\n先来看一下如果使用原生的JDBC进行事务管理，我们是怎样处理的。\npublic void test(){ try{ // 1. 获取连接 // 2. 设置非自动提交 // 3. 目标代码执行 // 4. 提交 }catch(Exception e){ // 4. 回滚 }finally{ // 5. 关闭连接，释放资源 } }\r这种编程式事务将事务管理的代码嵌入到业务方法中来控制事物的提交和回滚，每一个需要事务控制的地方，我们都需要写一遍事务控制的代码，很容易造成代码的冗余。\n然后我们再来回忆一下Aop中的环绕通知的编写方式。\npublic static Object logAround() throws Throwable { try { // 这个相当于@Before System.out.println(\u0026#34;[环绕前置]\u0026#34; + name + \u0026#34;开始执行，参数是\u0026#34; + Arrays.asList(args)); // 这个方法就相当于method.invoke(obj,args),返回的值就是调用的目标方法的返回值 proceed = pjp.proceed(args); // 这个相当于@AfterReturning System.out.println(\u0026#34;[返回通知]\u0026#34; + name + \u0026#34;执行正常结束，结果是\u0026#34; + proceed); } catch (Exception e) { throw new RuntimeException(e); // 这个相当于@AfterThrowing System.out.println(\u0026#34;[异常通知]\u0026#34; + name + \u0026#34;执行异常，异常信息是\u0026#34; + e); } finally { // 这个相当于@After System.out.println(\u0026#34;[环绕后置]\u0026#34; + name + \u0026#34;最终结束\u0026#34;); } }\r可以发现，环绕通知和最原始的编程式事务思路基本一致，并且事务管理代码是固定的，都是第一步获取连接，第二步设置非自动提交，第三步目标代码执行，第四步如果目标代码执行成功，提交事务；执行失败，回滚事务，最后一步关闭连接，释放资源。所以我们将事务管理代码的每一步作为一种横切关注点，可以通过AOP方法模块化，进而借助Spring Aop框架实现声明式事务管理。\n如果我们要自己写这个切面方法还是很复杂的，要考虑各种因素。所以Spring已经给我们提供了很多事务控制的切面，这些切面也叫事务管理器。根据不同的持久化层框架，Spring提供了不同的事务管理器，这些事务管理器就可以在目标方法前后进进行事务控制。\n这些事务管理器要如何使用呢？(如何利用这些事务管理器为方法添加事务)\n我们拿DataSourceTranscationManager举例：\n配置事务管理器，让其进行事务控制，因为事务管理器是一个切面，所以需要导入面向切面编程的几个包 -- 基础版 spring-aop-5.2.6.RELEASE.jar spring-aspects-5.2.6.RELEASE.jar -- 增强版 com.springsource.org.aspectj.weaver-1.7.2.RELEASE.jar aopalliance-1.0-sources.jar cglib-nodep-javadoc-2.2.jar\r开启基于注解的事务控制模式 \u0026lt;!-- 数据源 --\u0026gt; \u0026lt;bean id=\u0026#34;testDB1\u0026#34; class=\u0026#34;com.mchange.v2.c3p0.ComboPooledDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;user\u0026#34; value=\u0026#34;${jdbc.username}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${jdbc.password}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;jdbcUrl\u0026#34; value=\u0026#34;${jdbc.jdbcUrl}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;driverClass\u0026#34; value=\u0026#34;${jdbc.driverClass}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 1. 配置事务管理器让其进行事务控制：要导入面向切面编程的几个包--\u0026gt; \u0026lt;bean id=\u0026#34;sourceTransactionManager\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;testDB1\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 2. 开启基于注解的事务控制模式：依赖tx名称空间 --\u0026gt; \u0026lt;tx:annotation-driven transaction-manager=\u0026#34;sourceTransactionManager\u0026#34;/\u0026gt;\r给事务方法加注解 @Transactional public void checkOut(String userId, String bookId, int number) { // 减去图书库存 bookDao.updateBookStock(bookId, number); // 减去用户余额 Double bookPrice = bookDao.queryBookPrice(bookId); bookDao.updateUserBalance(userId, bookPrice * number); }\r三、Transactional 给事务方法加@Transactional注解，就代表声明了这个方法是事务方法，之后Spring就可以进行事务控制。但是@Transactional并不是表面这么简单，它还有很多的属性需要我们了解。\nisolation：事务的隔离级别\n先回忆一下什么是事务的隔离级别：【事务的隔离级别】\npropagation：事务的传播行为\n**rollbackFor：**让原本不回滚的异常(编译时异常)进行事务回滚\n**rollbackForClassName：**让原本不回滚的异常进行事务回滚，写全类名\n**noRollbackFor：**让原本回滚的异常(运行时异常)不进行事务回滚\n**noRollbackForClassName：**让原本回滚的异常不进行事务回滚，写全类名\n为什么需要这几个属性？\n如下图，这个方法已经声明了事务，并且方法抛出了FileNotFound的异常，但是数据库的值依然被修改了，事务并没有回滚。这是为什么呢？\n异常分类：\n运行时异常(非检查异常)：可以不用处理，默认都回滚\n编译时异常(受检查异常)：要么try-catch，要么在方法上声明throws，默认不回滚\n所以上图中事务没有回滚是因为FileNotFound是一个编译时异常，事务默认发生运行时异常会回滚，发生编译时异常不会回滚。\n有了这几个属性之后，可以让原来不回滚的异常进行事务回滚，让原本回滚的异常不进行事务回滚。\n@Transactional(rollbackFor={FileNotFoundException.class}) public void checkOut(String userId, String bookId, int number) throws InterruptedException, FileNotFoundException { // 加上这个异常回滚之后，遇到FileNotFoundException异常，事务就会回滚 }\rreadOnly：设置事务为只读事务，默认值为false\n@Transactional(readOnly = true) public void checkOut(String userId, String bookId, int number) { // 当方法中全是对数据库的查询操作时，可以设置readOnly = true，可以跳过事务控制的其他操作，加快查询速度 }\r如果方法中有增删改操作，但是事务设置readOnly = true，就会报错\ntimeout：事务超出指定执行时长后自动终止并回滚，以秒为单位\n@Transactional(timeout = 3) public void checkOut(String userId, String bookId, int number) { // 如果这个方法执行超过3秒，事务就会终止并回滚 }\r","date":"2023-09-07","id":3,"permalink":"/frameworks/spring/spring_basic/spring-transcationc/","summary":"\u003cp\u003e在学习声明式事务之前，我们先回忆一下什么是事务：\u003ca href=\"https://www.cnblogs.com/mark5/p/11076623.html\"\u003e【什么是事务】\u003c/a\u003e。既然是事务，就免不了要操作数据库，Spring提供了JdbcTemplate，可以快捷的操作数据库。\u003c/p\u003e\n\u003ch1 id=\"一jdbctemplate\"\u003e一、JdbcTemplate\u003c/h1\u003e\n\u003cp\u003eJdbcTemplate是Spring提供的进行数据访问的工具，想要使用JdbcTemplate，首先需要导入以下三个Jar包：\u003c/p\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003espring-jdbc-5.2.6.RELEASE.jar\nspring-orm-5.2.6.RELEASE.jar  // 对象关系映射\nspring-tx-5.2.6.RELEASE.jar   // 事务\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003cp\u003eJar包导入之后，怎么使用JdbcTemplate来操作数据库呢？\u003c/p\u003e\n\u003cp\u003e访问数据库，首先需要知道数据源，我们可以通过new的方式获取dataSource和JdbcTemplate，然后使用JdbcTemplate中的增删改查方法即可。\u003c/p\u003e\n\r\n\r\n\r\n\u003cdiv class=\"expressive-code\"\u003e\r\n  \u003cfigure class=\"frame not-content\"\u003e\r\n  \u003cfigcaption class=\"header\"\u003e\r\n    \u003cspan class=\"title\"\u003e\u003c/span\u003e\r\n  \u003c/figcaption\u003e\r\n  \u003cpre tabindex=\"0\"\u003e\u003ccode\u003e public void test() throws SQLException, PropertyVetoException {\n     JdbcTemplate jdbcTemplate = new JdbcTemplate();\n     ComboPooledDataSource dataSource = new ComboPooledDataSource();\n     dataSource.setUser(\u0026#34;\u0026#34;);\n     dataSource.setPassword(\u0026#34;\u0026#34;);\n     dataSource.setJdbcUrl(\u0026#34;\u0026#34;);\n     dataSource.setDriverClass(\u0026#34;\u0026#34;);\n\n     jdbcTemplate.setDataSource(dataSource);\n }\u003c/code\u003e\u003c/pre\u003e\r\n  \u003c/figure\u003e\r\n\u003c/div\u003e\r\n\u003cp\u003e另外一种方式，就是在Spring容器中注册dataSource和JdbcTemplate，我们要使用JdbcTemplate的时候，直接去Spring容器中取，之后再使用JdbcTemplate中的增删改查方法来操作数据库。\u003c/p\u003e","tags":[],"title":"声明式事务"},{"content":"Well-thought-through product announcements will help increase feature awareness and engage users with new functionality. Just like sharing your public roadmap, it\u0026rsquo;s also a great way to let potential customers see that you\u0026rsquo;re constantly improving.\nFurther reading Read How to announce product updates and features ","date":"2023-09-07","id":4,"permalink":"/blog/example-post/","summary":"You can use blog posts for announcing product updates and features.","tags":[],"title":"Example Post"},{"content":"","date":"2023-09-07","id":5,"permalink":"/blog/","summary":"","tags":[],"title":"Blog"},{"content":"","date":"2023-09-07","id":6,"permalink":"/java_core/jvm/virtual_machine/","summary":"","tags":[],"title":"JVM"},{"content":"什么是虚拟机？ 一、虚拟机 1. 什么是虚拟机？ 虚拟机(Virtual Machine)指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。 所谓虚拟机，就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。 2. 虚拟机可以分为两类： 系统虚拟机：它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台，比如Visual Box，VMware。 程序虚拟机：专门为执行单个计算机程序而设计，比如Java虚拟机，在Java虚拟机中执行的指令称为Java字节码指令。 无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。 二、Java虚拟机 1. 什么是Java虚拟机？ Java虚拟机是一台执行字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。 JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回收机制，以及可靠的即时编译器。 Java技术的核心就是Java虚拟机，因为所有的Java程序都运行在Java虚拟机内部。 可以这样理解: JVM类似于一台小电脑运行在windows或者linux这些操作系统环境下。它与操作系统直接交互，不与硬件直接交互，操作系统可以帮我们完成和硬件交互的工作。 JVM不是只支持Java字节码，只要编程语言能够遵循字节码文件的规范，都可以在JVM内运行 2. Java虚拟机是干什么的？ Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。 每一条Java指令，Java虚拟机规范中都有详细的定义，如怎么取操作数，怎么处理操作数，操作结果放在哪里。 3. Java虚拟机的主要特点 一次编译，到处运行 自动内存管理 自动垃圾回收机制 \u0026ldquo;一次编译，到处运行\u0026quot;怎么理解？ 对于不同的操作系统，Oracle提供了不同版本的JVM，所以只需要将程序编译成一个.class文件，就可以运行在不同操作系统的JVM上 4. 指令集架构模型 基于栈的指令集架构 设计和实现更简单，适用于资源受限的系统； 避开了寄存器的分配难题：使用零地址指令方式分配； JVM指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现； 不需要硬件支持，可移植性更好，更好实现跨平台。 由于跨平台性的设计，Java的指令都是根据栈来设计的。 基于寄存器的指令集架构 典型的应用是X86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机； 基于寄存器的指令集架构则完全依赖硬件，可移植性差； 性能优秀，执行更高效； 花费更少的指令去完成一项操作； 大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主 二者区别：举例说明 寄存器执行性能更好，为什么不更改成根据寄存器来设计？ 不同平台CPU架构不同，为了实现跨平台性，所以不能设计为基于寄存器的； 基于栈设计实现要简单一些； 基于栈在非资源受限平台(嵌入式)也是可以用的，没有必要更改。 5. JVM的生命周期 启动 Java虚拟机的启动是通过引导类加载器(bootstrap class loader)创建一个初始类(initial class)来完成的，这个类是由虚拟机的具体实现(虚拟机有不同公司开发的不同的版本)指定的。 执行 一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序； 程序开始执行时他才运行，程序结束时他就停止； 执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。 退出 程序正常执行结束； 程序在执行过程中遇到了异常(未被捕获)或错误而异常终止； 由于操作系统出现错误而导致Java虚拟机进程终止； 某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且Java安全管理也允许这次exit或halt操作。 JNI加载或卸载Java虚拟机，Java虚拟机退出 6. JVM整体结构 整体结构图 详细结构图 ","date":"2023-09-07","id":7,"permalink":"/java_core/jvm/virtual_machine/virtual-machine/","summary":"\u003ch1 id=\"section-1\"\u003e什么是虚拟机？\u003c/h1\u003e\n\u003ch1 id=\"chapter-1\"\u003e一、虚拟机\u003c/h1\u003e\n\u003ch2 id=\"section-1-1\"\u003e1. 什么是虚拟机？\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e虚拟机(Virtual Machine)指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。\u003c/li\u003e\n\u003cli\u003e所谓虚拟机，就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"section-1-2\"\u003e2. 虚拟机可以分为两类：\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e系统虚拟机：它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台，比如Visual Box，VMware。\u003c/li\u003e\n\u003cli\u003e程序虚拟机：专门为执行单个计算机程序而设计，比如Java虚拟机，在Java虚拟机中执行的指令称为Java字节码指令。\n无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"chapter-2\"\u003e二、Java虚拟机\u003c/h1\u003e\n\u003ch2 id=\"section-2-1\"\u003e1. 什么是Java虚拟机？\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003eJava虚拟机是一台执行字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。\u003c/li\u003e\n\u003cli\u003eJVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回收机制，以及可靠的即时编译器。\u003c/li\u003e\n\u003cli\u003eJava技术的核心就是Java虚拟机，因为所有的Java程序都运行在Java虚拟机内部。\n\u003cstrong\u003e可以这样理解:\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003eJVM类似于一台小电脑运行在windows或者linux这些操作系统环境下。它与操作系统直接交互，不与硬件直接交互，操作系统可以帮我们完成和硬件交互的工作。\u003c/li\u003e\n\u003cli\u003eJVM不是只支持Java字节码，只要编程语言能够遵循字节码文件的规范，都可以在JVM内运行\n     \r\n\r\n\u003cimg\r\n  src=\"/1592291665856-8bc51ef9-6ee7-4408-9343-3ef1aa7372dd_319100819319602114_hu_22beb13e41938c8f.webp\"\r\n  width=\"1705\"\r\n  height=\"315\"\r\n  decoding=\"async\"\r\n  fetchpriority=\"auto\"\r\n  loading=\"lazy\"\r\n  alt=\"\"\r\n  id=\"h-rh-i-0\"\r\n\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"section-2-2\"\u003e2. Java虚拟机是干什么的？\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003eJava虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。\u003c/li\u003e\n\u003cli\u003e每一条Java指令，Java虚拟机规范中都有详细的定义，如怎么取操作数，怎么处理操作数，操作结果放在哪里。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"section-2-3\"\u003e3. Java虚拟机的主要特点\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e一次编译，到处运行\u003c/li\u003e\n\u003cli\u003e自动内存管理\u003c/li\u003e\n\u003cli\u003e自动垃圾回收机制\n\u003cstrong\u003e\u0026ldquo;一次编译，到处运行\u0026quot;怎么理解？\u003c/strong\u003e\n对于不同的操作系统，Oracle提供了不同版本的JVM，所以只需要将程序编译成一个.class文件，就可以运行在不同操作系统的JVM上\n\r\n\r\n\u003cimg\r\n  src=\"/1592291938421-f47f0246-9e23-46e4-98ef-d642dc9d0ecd_9415740850356539932_hu_4d77ddbcd375a312.webp\"\r\n  width=\"936\"\r\n  height=\"543\"\r\n  decoding=\"async\"\r\n  fetchpriority=\"auto\"\r\n  loading=\"lazy\"\r\n  alt=\"\"\r\n  id=\"h-rh-i-1\"\r\n\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"section-2-4\"\u003e4. 指令集架构模型\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e基于栈的指令集架构\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e设计和实现更简单，适用于资源受限的系统；\u003c/li\u003e\n\u003cli\u003e避开了寄存器的分配难题：使用\u003cstrong\u003e零地址指令\u003c/strong\u003e方式分配；\u003c/li\u003e\n\u003cli\u003eJVM指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现；\u003c/li\u003e\n\u003cli\u003e不需要硬件支持，可移植性更好，更好实现跨平台。\n由于跨平台性的设计，Java的指令都是根据栈来设计的。\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e基于寄存器的指令集架构\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e典型的应用是X86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机；\u003c/li\u003e\n\u003cli\u003e基于寄存器的指令集架构则完全依赖硬件，可移植性差；\u003c/li\u003e\n\u003cli\u003e性能优秀，执行更高效；\u003c/li\u003e\n\u003cli\u003e花费更少的指令去完成一项操作；\u003c/li\u003e\n\u003cli\u003e大部分情况下，基于寄存器架构的指令集往往都以\u003cstrong\u003e一地址指令\u003c/strong\u003e、\u003cstrong\u003e二地址指令\u003c/strong\u003e和\u003cstrong\u003e三地址指令\u003c/strong\u003e为主\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e二者区别：举例说明\n \r\n\r\n\u003cimg\r\n  src=\"/1592292964453-ba574a07-3d16-4688-b2a5-363318ee2861_4299550262335268628_hu_14cf74460b18abfa.webp\"\r\n  width=\"1333\"\r\n  height=\"781\"\r\n  decoding=\"async\"\r\n  fetchpriority=\"auto\"\r\n  loading=\"lazy\"\r\n  alt=\"\"\r\n  id=\"h-rh-i-2\"\r\n\u003e\n\u003cstrong\u003e寄存器执行性能更好，为什么不更改成根据寄存器来设计？\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e不同平台CPU架构不同，为了实现跨平台性，所以不能设计为基于寄存器的；\u003c/li\u003e\n\u003cli\u003e基于栈设计实现要简单一些；\u003c/li\u003e\n\u003cli\u003e基于栈在非资源受限平台(嵌入式)也是可以用的，没有必要更改。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"section-2-5\"\u003e5. JVM的生命周期\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e启动\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eJava虚拟机的启动是通过引导类加载器(bootstrap class loader)创建一个初始类(initial class)来完成的，这个类是由虚拟机的具体实现(虚拟机有不同公司开发的不同的版本)指定的。\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e执行\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序；\u003c/li\u003e\n\u003cli\u003e程序开始执行时他才运行，程序结束时他就停止；\u003c/li\u003e\n\u003cli\u003e执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e退出\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e程序正常执行结束；\u003c/li\u003e\n\u003cli\u003e程序在执行过程中遇到了异常(未被捕获)或错误而异常终止；\u003c/li\u003e\n\u003cli\u003e由于操作系统出现错误而导致Java虚拟机进程终止；\u003c/li\u003e\n\u003cli\u003e某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且Java安全管理也允许这次exit或halt操作。\u003c/li\u003e\n\u003cli\u003eJNI加载或卸载Java虚拟机，Java虚拟机退出\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"section-2-6\"\u003e6. JVM整体结构\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e整体结构图\n\r\n\r\n\u003cimg\r\n  src=\"/1592293238440-5c0e5309-8c0f-4380-9b5c-9f17197371ee_8685009371071052695_hu_220652c16a3ea774.webp\"\r\n  width=\"1057\"\r\n  height=\"954\"\r\n  decoding=\"async\"\r\n  fetchpriority=\"auto\"\r\n  loading=\"lazy\"\r\n  alt=\"\"\r\n  id=\"h-rh-i-3\"\r\n\u003e\u003c/li\u003e\n\u003cli\u003e详细结构图\n\r\n\r\n\u003cimg\r\n  src=\"/1592293272780-92417562-dfae-46ef-8f03-b09c94471282_17732531737385754454_hu_fdde68c71d327fc0.webp\"\r\n  width=\"1222\"\r\n  height=\"1245\"\r\n  decoding=\"async\"\r\n  fetchpriority=\"auto\"\r\n  loading=\"lazy\"\r\n  alt=\"\"\r\n  id=\"h-rh-i-4\"\r\n\u003e\u003c/li\u003e\n\u003c/ol\u003e","tags":[],"title":"虚拟机"},{"content":"","date":"2023-09-07","id":8,"permalink":"/java_core/jvm/classloader/","summary":"","tags":[],"title":"Class Loader"},{"content":"1. 类装载器子系统 1.1 什么是类装载子系统？ 类装载器子系统负责从文件系统或者网络中加载Class文件，Class文件在文件开头有特定的文件标识(魔数)。\n类装载器子系统(ClassLoader)只负责Class文件的加载，至于它是否可以运行，则由执行引擎(Execution Engine)决定。（你妈妈[ClassLoader]给你[Execution Engine]找到相亲姑娘，是否能成得看你自己的本事）\n加载类的信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量(这部分常量信息是Class文件中常量池部分的内存映射)\n运行时常量池：常量池在运行时加载到内存里，就叫做运行时常量池\n1.2 类装载子系统架构图 1.3 类的加载过程\r1.3.1 加载 通过一个类的全限定名获取定义此类的二进制字节流。\n将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。\n在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口\n加载.class文件的方式\n从本地系统直接加载 通过网络获取，典型场景：Web Applet 从zip压缩包中读取，称为日后jar、war格式的基础 运行时计算生成，使用最多的是：动态代理技术(反射动态代理) 由其他文件生成，典型场景：JSP应用 从专有数据库中提取.class文件，少见 从加密文件中获取，典型的防Class文件被反编译的保护措施 1.3.2 链接 验证 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。 主要包括四种验证，文件格式验证，源数据验证，字节码验证，符号引用验证。 准备 为类变量分配内存并且设置该类变量的默认初始值，即零值； 这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化； 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到java堆中。 解析 将常量池内的符号引用转换为直接引用的过程。 符号引用：一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中。\n直接引用：直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄\n事实上，解析操作往往会伴随着jvm在执行完初始化之后再执行 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。 1.3.3 初始化：初始化模块，初始化阶段就是执行类构造器方法()的过程 即\u0026quot;class or interface initialization method\u0026quot;，他并不是指构造器(构造器是虚拟机视角下的())。\n此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。\n没有定义()，但是在二进制文件中()方法存在\n如果没有给变量赋值，也没有静态代码块，就不会有()方法 前向引用\n若该类具有父类，JVM会先调用父类的方法，再调用子类的方法 虚拟机必须保证一个类的方法在多线程下被同步加锁 一个类只会被加载一次，也就是说只会调用一次方法，类第一次被加载之后，会在内存中缓存起来，下次再使用这个类，直接从内存中取。\n举例说明：假设现在有两个线程th1，th2都想要加载类TestClass，如果线程th1抢到加载类的语句TestClass t = new TestClass()，th1就去加载类，因为会被同步加锁，th2就进不去加载类的方法，所以只会有一个线程可以成功打印初始化语句\n1.4 类加载器分类 1.4.1 引导类加载器：BootStrap ClassLoader 由C/C++语言实现，嵌套在JVM内部。\njava核心类库都是使用引导类加载器BootStrapClassLoader加载的。\n并不继承自ClassLoader，没有父加载器。\n加载扩展类加载器和应用类加载器，并指定他们的父类加载器，即ClassLoader。\n处于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的包\n1.4.2 自定义类加载器： 由Java实现。\nJava虚拟机规范将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器，从下图可以看到扩展类加载器ExtClassLoader，应用类加载器System ClassLoader间接继承ClassLoader，所以Extension Class Loader、System ClassLoader也是自定义类加载器。\r注意上图中的加载器划分关系为包含关系，不是上下层，也不是继承关系。(Java语言编写的自定义类加载器不会继承于C/C++实现的BootStrap ClassLoader，这种关系类似于等级制度)。\n扩展类加载器(Extension Class Loader)：JVM自带\njava语言编写 ，由sun.misc.Launcher$ExtClassLoader实现 派生于ClassLoader类 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录(扩展目录)下加载类库。如果用户创建的JAR放在此目录下，也会由拓展类加载器自动加载 应用程序类加载器(系统类加载器，System Class Loader)：JVM自带 java语言编写， 由sun.misc.Launcher$AppClassLoader实现。 派生于ClassLoader类 它负责加载环境变量classpath或系统属性 java.class.path指定路径下的类库 该类加载器是程序中默认的类加载器，一般来说，java应用的类都是由它来完成加载 通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器 程序员自定义类加载器 为什么要自定义类加载器？\n隔离加载类：确保框架jar包和中间件jar包不冲突\n修改类加载的方式：在需要的时候动态加载\n扩展加载源\n防止源码泄露\n如何自定义类加载器？\n继承ClassLoader类\n把自定义的类加载逻辑及卸载findClass()方法中(JDK1.2之前需要重写loaderClass()方法，JDK1.2之后不建议覆盖loaderClass()，而是重写findClass())\n如果需求不复杂，也可以直接继承URLClassLoader类，这样可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁 获取不同类的加载器代码演示 /** * ClassLoader加载 */ public class ClassLoaderTest { public static void main(String[] args) { //获取系统类加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); System.out.println(systemClassLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2 //获取其上层 扩展类加载器 ClassLoader extClassLoader = systemClassLoader.getParent(); System.out.println(extClassLoader);//sun.misc.Launcher$ExtClassLoader@610455d6 //获取其上层 获取不到引导类加载器 ClassLoader bootStrapClassLoader = extClassLoader.getParent(); System.out.println(bootStrapClassLoader);//null //对于用户自定义类来说：使用系统类加载器进行加载 ClassLoader classLoader = ClassLoaderTest.class.getClassLoader(); System.out.println(classLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2 //String 类使用引导类加载器进行加载的 --\u0026gt;java核心类库都是使用引导类加载器加载的 ClassLoader classLoader1 = String.class.getClassLoader(); System.out.println(classLoader1);//null获取不到间接证明了String 类使用引导类加载器进行加载的 } }\r📋 /** * 虚拟机自带加载器 */ public class ClassLoaderTest1 { public static void main(String[] args) { System.out.println(\u0026#34;********启动类加载器*********\u0026#34;); // 1. 获取BootStrapClassLoader能够加载的api路径 URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs(); /* 打印结果 file:/E:/software/java/java/jdk/jdk1.8.0_131/jre/lib/resources.jar file:/E:/software/java/java/jdk/jdk1.8.0_131/jre/lib/rt.jar file:/E:/software/java/java/jdk/jdk1.8.0_131/jre/lib/sunrsasign.jar file:/E:/software/java/java/jdk/jdk1.8.0_131/jre/lib/jsse.jar file:/E:/software/java/java/jdk/jdk1.8.0_131/jre/lib/jce.jar file:/E:/software/java/java/jdk/jdk1.8.0_131/jre/lib/charsets.jar file:/E:/software/java/java/jdk/jdk1.8.0_131/jre/lib/jfr.jar file:/E:/software/java/java/jdk/jdk1.8.0_131/jre/classes */ for (URL e:urls){ System.out.println(e.toExternalForm()); } // 2. 从上面的路径中随意选择一个类 看看他的类加载器是什么 //Provider位于 /jdk1.8.0_171.jdk/Contents/Home/jre/lib/jsse.jar 下 ClassLoader classLoader = Provider.class.getClassLoader(); // 3. 引导类加载器是获取不到的，这里为null也可以说明该类是由引导类加载器获取的 System.out.println(classLoader);//null System.out.println(\u0026#34;********拓展类加载器********\u0026#34;); // 扩展类加载器从java.ext.dirs系统属性所指定的目录中加载类库 String extDirs = System.getProperty(\u0026#34;java.ext.dirs\u0026#34;); // E:\\software\\java\\java\\jdk\\jdk1.8.0_131\\jre\\lib\\ext // C:\\Windows\\Sun\\Java\\lib\\ext for (String path : extDirs.split(\u0026#34;;\u0026#34;)){ System.out.println(path); } //从上面的路径中随意选择一个类 看看他的类加载器是什么:拓展类加载器 ClassLoader classLoader1 = CurveDB.class.getClassLoader(); System.out.println(classLoader1);//sun.misc.Launcher$ExtClassLoader@4dc63996 } }\r1.5 ClassLoader 抽象类，除了启动类加载器，其他所有的类加载器都直接或者间接继承自ClassLoader。\nClassLoader的常用方法 获取ClassLoader的途径：\n获取当前类的ClassLoader：clazz.getClassLoader()\n获取当前线程上下文的ClassLoader：Thread.currentThread.getContextClassLoader()\n获取系统的ClassLoader：ClassLoader.getSystemClassLoader()\n获取调用者的ClassLoader：DriverManager.getCallerClassLoader()\n2. 双亲委派机制 2.1 双亲委派机制工作原理 2.1.1 原理 Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存，生成class对象。\n加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。\n2.1.2 举例说明 自定义一个java.lang.String，然后在另外的类中调用String类，会发现只打印了\u0026quot;hello\u0026quot;，没有打印\u0026quot;我是自定义加载类\u0026quot;，也就是说，Java其实没有调用我们自定义的String类\r这就是因为双亲委派机制，最上层的引导类加载器发现自己可以完成加载任务[BootStrap引导类加载器只加载包名为java、javax、sun等开头的类]，所以就去加载了核心类库中的String类，没有加载用户自定义的String类。\n而且核心类库中的String并没有main方法，在自定义的String类中运行main方法，加载的类是核心类库的String类，就会报找不到main方法的错误\n假设项目中用到SPI接口，SPI属于核心API，需要使用引导类加载器，引导类加载器加载rt.jar，就加载了SPI核心类，之后用到了SPI接口，属于第三方jar包，不属于核心jar，需要用系统类加载器加载，所以就要反向委派，引导类加载器委派线程上下文加载器去加载SPI接口实现，就是说核心API用引导类加载器加载，第三方API用系统类加载器加载 2.2 双亲委派机制的优势 避免类的重复加载(一个类只会被一个类加载器加载，而且一定会被加载)。\n保护程序安全，防止核心API被随意篡改\n假设我们现在要在java.lang包下定义一个类MyString，类加载的时候，引导类加载器发现这个类归它加载，但是java.lang包需要访问权限，所以就会报错\n2.3 沙箱安全机制 自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载过程中会先加载jdk自带的文件(rt.jar包中的java\\lang\\String.class)，报错信息说没有main方法就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。\n3. 补充内容 3.1 在jvm中表示两个class对象是否为同一个类的两个必要条件 类的完整类名必须一致，包括包名。\n加载这个类的ClassLoader(指ClassLoader实例对象)必须相同\n换句话说，在jvm中，即使这两个类对象(class对象)来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的.\n自定义的java.lang.String类和核心库中的java.lang.String，前者的ClassLoader是系统类加载器，后者的ClassLoader是引导类加载器，所以这两个String不是同一个类\n3.2 对类加载器的引用 JVM必须知道一个类型是由启动类加载器加载的还是由用户类加载器加载的。如果一个类型由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证两个类型的类加载器是相同的。\n3.3 Java程序对类的使用方式分为主动使用和被动使用 主动使用和被动使用的区别就是是否会导致类的初始化\n3.3.1 主动使用，分为七种情况 创建类的实例\n访问某个类或接口的静态变量，或者对静态变量赋值\n调用类的静态方法\n反射，比如Class.forName(com.dsh.jvm.xxx)\n初始化一个类的子类\nJava虚拟机启动时被标明为启动类的类\nJDK7 开始提供的动态语言支持： java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化\n除了以上七种情况，其他使用java类的方式都被看作是对类的被动使用，都不会导致类的初始化。\n","date":"2023-09-07","id":9,"permalink":"/java_core/jvm/classloader/classloader/","summary":"\u003ch2 id=\"1-类装载器子系统\"\u003e1. 类装载器子系统\u003c/h2\u003e\n\u003ch3 id=\"11-什么是类装载子系统\"\u003e1.1 什么是类装载子系统？\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e类装载器子系统负责从文件系统或者网络中加载Class文件，Class文件在文件开头有特定的文件标识(魔数)。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e类装载器子系统(ClassLoader)只负责Class文件的加载，至于它是否可以运行，则由执行引擎(Execution Engine)决定。（你妈妈[ClassLoader]给你[Execution Engine]找到相亲姑娘，是否能成得看你自己的本事）\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e加载类的信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放\u003cstrong\u003e运行时常量池\u003c/strong\u003e信息，可能还包括字符串字面量和数字常量(这部分常量信息是Class文件中常量池部分的内存映射)\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e运行时常量池：常量池在运行时加载到内存里，就叫做运行时常量池\u003c/p\u003e\n\u003ch3 id=\"12-类装载子系统架构图\"\u003e1.2 类装载子系统架构图\u003c/h3\u003e\n\u003ch4 id=\"heading\"\u003e    \r\n\r\n\u003cimg\r\n  src=\"/1592294273696-75a39df4-8134-42cc-a2ec-171e9148974d_18275658206902580544_hu_ac57167d51750d95.webp\"\r\n  width=\"1092\"\r\n  height=\"446\"\r\n  decoding=\"async\"\r\n  fetchpriority=\"auto\"\r\n  loading=\"lazy\"\r\n  alt=\"\"\r\n  id=\"h-rh-i-0\"\r\n\u003e\u003c/h4\u003e\n\u003ch3 id=\"13-类的加载过程\"\u003e1.3 类的加载过程\r\n\r\n\u003cimg\r\n  src=\"/1592296953006-ef0cc2eb-bcc6-4b97-9147-8996a9a93f08_12893937654689967772_hu_7cf9c9115c0a95f0.webp\"\r\n  width=\"1692\"\r\n  height=\"785\"\r\n  decoding=\"async\"\r\n  fetchpriority=\"auto\"\r\n  loading=\"lazy\"\r\n  alt=\"\"\r\n  id=\"h-rh-i-1\"\r\n\u003e\u003c/h3\u003e\n\u003ch4 id=\"131-加载\"\u003e1.3.1 加载\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e通过一个类的全限定名获取定义此类的二进制字节流。\u003c/p\u003e","tags":[],"title":"类加载系统"},{"content":"","date":"2023-09-07","id":10,"permalink":"/java_core/jvm/runtime_data_area/","summary":"","tags":[],"title":"运行时数据区"},{"content":"1. 什么是PC寄存器(程序计数器)？ JVM中的程序计数寄存器(Program Counter Register)中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。JVM中的PC寄存器并不是广义上所指的物理寄存器，是对物理PC寄存器的一种抽象模拟。\n它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域。\n在jvm规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。\n任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的java方法的JVM指令地址；如果是在执行native方法，则是未指定值(undefined)。\n它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。\n字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。\n它是唯一一个在Java虚拟机规范中没有规定任何OOM情况的区域，也没有GC\n2. PC寄存器的作用 PC寄存器是用来存储指向下一条指令的地址，也就是即将要执行的指令代码。由执行引擎读取下一条指令。 | 使用PC寄存器存储字节码指令地址有什么用**/**为什么使用PC寄存器记录当前线程的执行地址？\n因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。 JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。 | PC寄存器为什么会设定为线程私有\n所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停的做任务切换，这样必然会导致经常中断或恢复，为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法就是为每一个线程都分配一个PC寄存器,这样各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。[每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响]\n**| 举例说明：**1个cpu并发执行3个线程，cpu首先执行线程1，假设线程1执行到第4行，cpu切换为执行线程2，那么PC寄存器就会存储线程1下一个字节码指令地址5，然后执行线程2，线程2执行到第6行，cpu切换为执行线程3，那么PC寄存器就会存储线程2下一个字节码指令地址7，如果CPU寄存器是公用的，那么线程2的字节码指令地址7就会覆盖线程1字节码指令地址5，当cpu再切换回执行线程1，就会执行错误，所以PC寄存器设定为线程私有，各个线程之间独立计算\n3. CPU时间片 由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令，这样必然导致经常中断或恢复。\nCPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段。称作它的时间片。\n在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。\n在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。\n4. 并行与并发 并行：系统有一个以上CPU时,则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。\n并发：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。\n区别：\n并发和并行是即相似又有区别的两个概念，并行是指两个或者多个事件在同一时刻发生； 而并发是指两个或多个事件在同一时间间隔内发生。在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。倘若在计算机系统中有多个处理机，则这些可以并发执行的程序便可被分配到多个处理机上，实现并行执行，即利用每个处理机来处理一个可并发执行的程序，这样，多个程序便可以同时执行。 ","date":"2023-09-07","id":11,"permalink":"/java_core/jvm/runtime_data_area/program-counter-register/","summary":"\u003ch3 id=\"1-什么是pc寄存器程序计数器\"\u003e1. 什么是PC寄存器(程序计数器)？\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eJVM中的程序计数寄存器(Program Counter Register)中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。JVM中的PC寄存器并不是广义上所指的物理寄存器，是对物理PC寄存器的一种抽象模拟。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在jvm规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的java方法的JVM指令地址；如果是在执行native方法，则是未指定值(undefined)。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e它是唯一一个在Java虚拟机规范中没有规定任何OOM情况的区域，也没有GC\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e   \r\n\r\n\u003cimg\r\n  src=\"/1592303565144-6734cf1f-578f-4dcf-b4d2-04f5ccc82d2f_1104819481997742485_hu_d9cdd580366d63e3.webp\"\r\n  width=\"1134\"\r\n  height=\"966\"\r\n  decoding=\"async\"\r\n  fetchpriority=\"auto\"\r\n  loading=\"lazy\"\r\n  alt=\"\"\r\n  id=\"h-rh-i-0\"\r\n\u003e\u003c/p\u003e\n\u003ch3 id=\"2-pc寄存器的作用\"\u003e2. PC寄存器的作用\u003c/h3\u003e\n\u003cp\u003ePC寄存器是用来存储指向下一条指令的地址，也就是即将要执行的指令代码。由执行引擎读取下一条指令。\n\r\n\r\n\u003cimg\r\n  src=\"/1592303662466-6bc2252d-87d1-4f7e-9c33-48315bf57493_15164678382221252897_hu_f5ab4327f38696d9.webp\"\r\n  width=\"1738\"\r\n  height=\"891\"\r\n  decoding=\"async\"\r\n  fetchpriority=\"auto\"\r\n  loading=\"lazy\"\r\n  alt=\"\"\r\n  id=\"h-rh-i-1\"\r\n\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e|\u003c/strong\u003e  使用PC寄存器存储字节码指令地址有什么用**/**为什么使用PC寄存器记录当前线程的执行地址？\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。\u003c/li\u003e\n\u003cli\u003eJVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e      \u003cstrong\u003e|\u003c/strong\u003e  PC寄存器为什么会设定为线程私有\u003c/p\u003e","tags":[],"title":"程序计数器"},{"content":"","date":"2023-09-07","id":12,"permalink":"/frameworks/spring/","summary":"","tags":[],"title":"Spring "},{"content":"","date":"2023-09-07","id":13,"permalink":"/java_core/java_core/","summary":"","tags":[],"title":"Spring "},{"content":"","date":"2023-09-07","id":14,"permalink":"/frameworks/spring_mvc/","summary":"","tags":[],"title":"Spring MVC"},{"content":"","date":"2023-09-07","id":15,"permalink":"/frameworks/spring/spring_resource/","summary":"","tags":[],"title":"Spring源码"},{"content":"Reference pages are ideal for outlining how things work in terse and clear terms. Less concerned with telling a story or addressing a specific use case, they should give a comprehensive outline of what your documenting.\nFurther reading Read about reference in the Diátaxis framework ","date":"2023-09-07","id":16,"permalink":"/frameworks/spring_mvc/example/","summary":"\u003cp\u003eReference pages are ideal for outlining how things work in terse and clear terms. Less concerned with telling a story or addressing a specific use case, they should give a comprehensive outline of what your documenting.\u003c/p\u003e","tags":[],"title":"Example Reference"},{"content":"","date":"2023-09-07","id":17,"permalink":"/frameworks/spring/spring_resource/spring%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0-/","summary":"","tags":[],"title":"Spring源码解析"},{"content":"","date":"2023-09-07","id":18,"permalink":"/architecture/","summary":"","tags":[],"title":"Docs"},{"content":"","date":"2023-09-07","id":19,"permalink":"/database/","summary":"","tags":[],"title":"Docs"},{"content":"","date":"2023-09-07","id":20,"permalink":"/middleware/","summary":"","tags":[],"title":"Docs"},{"content":"","date":"2023-09-07","id":21,"permalink":"/tools/","summary":"","tags":[],"title":"Docs"},{"content":"","date":"2023-09-07","id":22,"permalink":"/java_core/","summary":"","tags":[],"title":"Java\u0026JVM"},{"content":"","date":"2023-09-07","id":23,"permalink":"/java_core/jvm/","summary":"","tags":[],"title":"JVM"},{"content":"","date":"2023-09-07","id":24,"permalink":"/privacy/","summary":"","tags":[],"title":"Privacy Policy"},{"content":"","date":"2023-09-07","id":25,"permalink":"/","summary":"","tags":[],"title":"Keep thinking, keep loving."},{"content":"","date":"2023-09-07","id":26,"permalink":"/frameworks/","summary":"","tags":[],"title":"Frameworks"},{"content":"","date":"0001-01-01","id":27,"permalink":"/categories/","summary":"","tags":[],"title":"Categories"},{"content":"","date":"0001-01-01","id":28,"permalink":"/contributors/","summary":"","tags":[],"title":"Contributors"},{"content":"","date":"0001-01-01","id":29,"permalink":"/tags/","summary":"","tags":[],"title":"Tags"}]